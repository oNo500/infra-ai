---
title: 使用循环进行 Min/Max 而不是排序
impact: LOW
impactDescription: O(n) instead of O(n log n)
tags: 'javascript, arrays, performance, sorting, algorithms'
---

## 使用循环进行 Min/Max 而不是排序

查找最小或最大元素只需要遍历数组一次。排序既浪费又慢。

**Incorrect (O(n log n) - 排序以查找最新的):**

```typescript
interface Project {
  id: string
  name: string
  updatedAt: number
}

function getLatestProject(projects: Project[]) {
  const sorted = [...projects].sort((a, b) => b.updatedAt - a.updatedAt)
  return sorted[0]
}
```

仅仅为了找到最大值而对整个数组进行排序。

**Incorrect (O(n log n) - 排序以查找最旧和最新的):**

```typescript
function getOldestAndNewest(projects: Project[]) {
  const sorted = [...projects].sort((a, b) => a.updatedAt - b.updatedAt)
  return { oldest: sorted[0], newest: sorted[sorted.length - 1] }
}
```

当只需要 min/max 时，仍然不必要地进行排序。

**Correct (O(n) - 单次循环):**

```typescript
function getLatestProject(projects: Project[]) {
  if (projects.length === 0) return null
  
  let latest = projects[0]
  
  for (let i = 1; i < projects.length; i++) {
    if (projects[i].updatedAt > latest.updatedAt) {
      latest = projects[i]
    }
  }
  
  return latest
}

function getOldestAndNewest(projects: Project[]) {
  if (projects.length === 0) return { oldest: null, newest: null }
  
  let oldest = projects[0]
  let newest = projects[0]
  
  for (let i = 1; i < projects.length; i++) {
    if (projects[i].updatedAt < oldest.updatedAt) oldest = projects[i]
    if (projects[i].updatedAt > newest.updatedAt) newest = projects[i]
  }
  
  return { oldest, newest }
}
```

单次遍历数组，无复制，无排序。

**Alternative (Math.min/Math.max 适用于小数组):**

```typescript
const numbers = [5, 2, 8, 1, 9]
const min = Math.min(...numbers)
const max = Math.max(...numbers)
```

这适用于小数组，但对于非常大的数组，由于展开运算符的限制，可能会更慢或者直接抛出错误。Chrome 143 中最大数组长度约为 124000，Safari 18 中约为 638000；具体数字可能会有所不同 - 请参阅 [此 fiddle](https://jsfiddle.net/qw1jabsx/4/)。为了可靠性，请使用循环方法。
